---
title: "Case Study: Replicating Mishra et al. (2020)"
author: "Sebastian Funk"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Replicating Mishra et al. (2020)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

This vignette demonstrates how to replicate the analysis from Mishra et al. (2020) of COVID-19 transmission dynamics in South Korea using EpiAwareR. This case study showcases the compositional modelling approach by building a complete epidemiological model from three reusable components.

The analysis estimates the time-varying reproduction number ($R_t$) using:

- **AR(2) latent process** for smooth evolution of log $R_t$
- **Renewal equation** for infection dynamics
- **Negative binomial observation model** for overdispersed case counts

```{r load_silent, echo = FALSE, message = FALSE}
library(EpiAwareR)
```

## Data Preparation

For this vignette, we simulate data similar to the South Korea COVID-19 outbreak analyzed in Mishra et al. (2020):

```{r simulated_data}
# Simulated daily case counts
set.seed(123)
dates <- seq.Date(as.Date("2020-02-15"), by = "day", length.out = 36)

# Simulate epidemic with changing Rt (intervention effect)
infections <- numeric(36)
infections[1:7] <- 50
for (i in 8:36) {
  rt <- if (i < 20) 2.5 else 0.8 # Intervention reduces transmission
  infections[i] <- rpois(1, rt * mean(infections[(i - 7):(i - 1)]))
}

training_data <- data.frame(
  date = dates,
  y_t = pmax(infections, 1) # Ensure positive counts
)

head(training_data)
```

## Model Components

### 1. Latent Process: AR(2) Model

The AR(2) process models the evolution of log $R_t$ over time with temporal autocorrelation:

$$\log R_t = \phi_1 \log R_{t-1} + \phi_2 \log R_{t-2} + \epsilon_t$$

where $\epsilon_t \sim \text{Normal}(0, \sigma^2)$.

```{r latent_model}
ar2 <- AR(
  order = 2,
  damp_priors = list(
    truncnorm(0.2, 0.2, 0, 1), # φ₁: First damping coefficient
    truncnorm(0.1, 0.05, 0, 1) # φ₂: Second damping coefficient
  ),
  init_priors = list(
    norm(0, 0.2), # Initial value for lag 1
    norm(0, 0.2) # Initial value for lag 2
  ),
  std_prior = halfnorm(0.1) # σ: Innovation standard deviation
)

print(ar2)
```

**Prior choices (from Mishra et al. 2020):**

- Damping coefficients truncated to [0,1] ensure stationarity
- Weak priors on initial values (centered at 0 on log scale → $R_t \approx 1$)
- Small innovation variance for smooth trajectories

### 2. Infection Model: Renewal Equation

The renewal equation models new infections based on past infections and generation time:

$$I_t = R_t \sum_{s=1}^{t} I_{t-s} \cdot g_s$$

where $g_s$ is the discretized generation time distribution.

```{r infection_model}
renewal <- Renewal(
  gen_distribution = gamma_dist(6.5, 0.62), # Shape and scale parameters
  initialisation_prior = norm(log(1.0), 0.1) # Prior on initial log infections
)

print(renewal)
```

**Key parameters:**

- Generation time: Mean ~6.5 days (typical for COVID-19 in early 2020)
- Gamma distribution allows flexible shape
- Initial infections seeded near 1 (on natural scale)

### 3. Observation Model: Negative Binomial

Links latent infections to observed case counts with overdispersion:

$$Y_t \sim \text{NegBinom}(\mu = I_t, \phi)$$

where $\phi$ controls overdispersion (clustering).

```{r observation_model}
negbin <- NegativeBinomialError(
  cluster_factor_prior = halfnorm(0.1)
)

print(negbin)
```

**Parameterization:**

- Cluster factor = $\sqrt{1/\phi}$ (coefficient of variation)
- Half-normal prior encourages moderate overdispersion
- More interpretable than directly specifying $\phi$

## Compose and Fit

### Create Complete Model

```{r compose_model}
model <- EpiProblem(
  epi_model = renewal,
  latent_model = ar2,
  observation_model = negbin,
  tspan = c(1, 36) # Time span matching our data
)

print(model)
```

The `EpiProblem` combines components into a joint Bayesian model with automatic validation.

### Bayesian Inference

We use NUTS (No-U-Turn Sampler) for posterior inference:

```{r fit_model, eval = FALSE}
results <- fit(
  model = model,
  data = training_data,
  method = nuts_sampler(
    warmup = 1000, # Adaptation iterations
    draws = 1000, # Posterior samples per chain
    chains = 4 # Independent chains for convergence assessment
  )
)
```

```{r fit_model_fast, echo = FALSE, eval = FALSE}
# For vignette building, use fewer samples
results <- fit(
  model = model,
  data = training_data,
  method = nuts_sampler(warmup = 100, draws = 100, chains = 2)
)
```

**Note**: Fitting typically takes 2-5 minutes on modern hardware.

## Results

### Convergence Diagnostics

```{r results, eval = FALSE}
print(results)
```

Check for:

- **Rhat < 1.1**: Chains have converged to the same distribution
- **ESS > 100**: Sufficient effective sample size for inference
- **No divergent transitions**: NUTS is exploring the posterior efficiently

### Parameter Summaries

```{r summaries, eval = FALSE}
# Detailed posterior summaries
summary(results)
```

Key parameters to examine:

- **AR damping coefficients** ($\phi_1$, $\phi_2$): Autocorrelation strength
- **Innovation std** ($\sigma$): Variability in $R_t$ changes
- **Cluster factor**: Degree of case count overdispersion
- **Initial infections**: Epidemic seeding

### Visualization

```{r plots, eval = FALSE}
# Time-varying reproduction number with credible intervals
plot(results, type = "Rt")

# Observed vs predicted case counts
plot(results, type = "cases")

# Posterior distributions for key parameters
plot(results, type = "posterior")
```

## Model Comparisons

### Comparing Latent Processes

Test sensitivity to AR order:

```{r compare_ar, eval = FALSE}
# AR(1) alternative
ar1 <- AR(
  order = 1,
  damp_priors = list(truncnorm(0.5, 0.2, 0, 1)),
  init_priors = list(norm(0, 0.2)),
  std_prior = halfnorm(0.1)
)

model_ar1 <- EpiProblem(
  epi_model = renewal,
  latent_model = ar1,
  observation_model = negbin,
  tspan = c(1, 36)
)

results_ar1 <- fit(model_ar1, data = training_data)

# Compare using LOO (leave-one-out cross-validation)
library(loo)
loo_compare(loo(results$samples), loo(results_ar1$samples))
```

### Adding Observation Delays

Account for incubation and reporting delays:

```{r add_delays, eval = FALSE}
# Incubation period (~5 days)
obs_incubation <- LatentDelay(
  model = negbin,
  delay_distribution = lognorm(1.6, 0.42)
)

# Reporting delay (~2 days)
obs_full <- LatentDelay(
  model = obs_incubation,
  delay_distribution = lognorm(0.58, 0.47)
)

model_delays <- EpiProblem(
  epi_model = renewal,
  latent_model = ar2,
  observation_model = obs_full,
  tspan = c(1, 36)
)

results_delays <- fit(model_delays, data = training_data)
```

## Interpretation

The Mishra et al. (2020) analysis demonstrated:

1. **Flexible $R_t$ estimation**: AR(2) captures both smooth trends and rapid changes
2. **Uncertainty quantification**: Bayesian credible intervals reflect parameter uncertainty
3. **Intervention detection**: Sharp decline in $R_t$ coincides with public health measures
4. **Compositional flexibility**: Easy to test alternative assumptions (AR order, delays)

### Key Findings

- Initial $R_t \approx 2.5$: Rapid exponential growth phase
- Post-intervention $R_t < 1$: Control achieved through distancing measures
- Moderate overdispersion: Case counts show clustering but not extreme variance
- Good model fit: Posterior predictive checks show data within credible intervals

## Extensions

Try modifying the analysis:

1. **Different priors**: Test sensitivity to prior choices
2. **Alternative latent models**: MA, random walk, spline models
3. **Stratification**: Separate models by age group or region
4. **Forecast evaluation**: Hold-out validation of predictive performance

## References

Mishra, S., Berah, T., Mellan, T. A., et al. (2020). On the derivation of the renewal equation from an age-dependent branching process: an epidemic modelling perspective. *arXiv preprint arXiv:2006.16487*.

## Session Info

```{r session_info}
sessionInfo()
```
